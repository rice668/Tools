
What is the difference between final, finally and finalize() in Java?

finalize() - method belongs to Object class. The method that is invoked
while doing the garbage collection of the object. 另外，所有Override finalize
的对象都会有一个FinalReference的引用，这样的对象在new的时候会进入一个Queue里面，再释放
资源的时候会从Queue里面一个一个的拿出来，一般的像这样的对象这样做并没有什么太大的问题，但是
FIS这样的对象在close之后，本不应该这样做了，如果这样做，那么就是GC在工作，导致STW(Stop
the world),但是具体导致什么问题，还得看你的垃圾收集器具体的类型。G1的话，是STW的问题，如果
是并发垃圾收集器，可能没有，所以一般的服务器都是都种多种垃圾收集器并存。

finally() - 不管try里面发生了什么事情，比如System.exit(0),都会执行finally里面的动作，比
如释放锁，释放数据库的连接，关闭流。
finally {
      this.readLock.unlock();
    }

What is the difference between equals() and == ?

== operator is used to compare the references of the objects. 也就是比较２个对象的地址
equals 比较２个对象是否相等

一个楼梯有20级，每次走1级或2级，请问从底走到顶一共有多少种走法？
Ans: 考虑下楼，第一次下一楼后有f(n-1)种走法，或者第一次下２楼有f(n-2)种走法，这样
f(n) = f(n-1) + f(n-2)

一个人上台阶可以一次上1个，2个，或者3个，问这个人上n层的台阶，总共有几种走法？
Ans: 思路同样，第一次上一个台阶后还剩下f(n-1)种走法，第一次上2个台阶后还剩下f(n-2)种走法，
第一次上三个台阶还剩下f(n-3)种走法。所以:　f(n) = f(n-1) + f(n-2) + f(n-3)

如何求解3^n次方？二分思路
3^n = 3^(n/2)*3^(n/2) if (n%2==0),这样只要算一次就可以了

？？？
当后端是缓存服务器时，经常使用一致性哈希算法来进行负载均衡。









