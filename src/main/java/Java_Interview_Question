
What is the difference between final, finally and finalize() in Java?

finalize() - method belongs to Object class. The method that is invoked
while doing the garbage collection of the object. 另外，所有Override finalize
的对象都会有一个FinalReference的引用，这样的对象在new的时候会进入一个Queue里面，再释放
资源的时候会从Queue里面一个一个的拿出来，一般的像这样的对象这样做并没有什么太大的问题，但是
FIS这样的对象在close之后，本不应该这样做了，如果这样做，那么就是GC在工作，导致STW(Stop
the world),但是具体导致什么问题，还得看你的垃圾收集器具体的类型。G1的话，是STW的问题，如果
是并发垃圾收集器，可能没有，所以一般的服务器都是都种多种垃圾收集器并存。

finally() - 不管try里面发生了什么事情，比如System.exit(0),都会执行finally里面的动作，比
如释放锁，释放数据库的连接，关闭流。
finally {
      this.readLock.unlock();
    }

What is the difference between equals() and == ?

== operator is used to compare the references of the objects. 也就是比较２个对象的地址
equals 比较２个对象是否相等

一个楼梯有20级，每次走1级或2级，请问从底走到顶一共有多少种走法？
Ans: 考虑下楼，第一次下一楼后有f(n-1)种走法，或者第一次下２楼有f(n-2)种走法，这样
f(n) = f(n-1) + f(n-2)

一个人上台阶可以一次上1个，2个，或者3个，问这个人上n层的台阶，总共有几种走法？
Ans: 思路同样，第一次上一个台阶后还剩下f(n-1)种走法，第一次上2个台阶后还剩下f(n-2)种走法，
第一次上三个台阶还剩下f(n-3)种走法。所以:　f(n) = f(n-1) + f(n-2) + f(n-3)

如何求解3^n次方？二分思路
3^n = 3^(n/2)*3^(n/2) if (n%2==0),这样只要算一次就可以了

谈谈你对分布式缓存的理解mem-cached ?

类加载过程?

加载（Loading）
1. 通过类名去获取此类的二进制字节流
【怎么获取这个Class类，并没有说一定要从哪里去获取，可以从网络(比如一个输入或者输出流；也可以从数据库反序列化出来)】
2. 将这个字节流代表的静态存储结构变成方法区运行时候的数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class对象，供以后去使用

验证（Verification）
Main idea: 确保当前的Class文件的结构符合虚拟机的要求，确保不会把虚拟机给弄坏。

准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和

卸载(Unloading): 也就是垃圾回收掉了。

Java的动态代理-->Spring AOP :http://www.iteye.com/topic/1123293
在代理模式中，我们创建具有现有对象的对象【代理对象】，以便向外界提供功能接口。
意图：为其他对象提供一种代理以控制对这，纵横交流是个很好的话题，但没有一个历史背景或者生活背景作为参照物，很难持续延伸。个对象的访问。
主要解决：在直接访问对象时带来的问题

Java反射知识-->Spring IoC :http://www.iteye.com/topic/1123081

今天和永城聊了一会技术关于宙斯里面的东西＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
1. 工厂模式，分为简单工厂和抽象工厂，什么时候用工厂呢？数据源
2. 单例模式，一般用在资源文件，一般实例化一次就OK

接下来需要看看设计模式在hadoop里面的运用

单例模式：
DelegationTokenRenewer.java
https://issues.apache.org/jira/browse/HADOOP-9049

Currently, DelegationTokenRenewer is not singleton.
Each filesystem using it spawns its own DelegationTokenRenewer.
A single DelegationTokenRenewer should be sufficient for all FileSystems.

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

public final class TwitterStreamFactory implements java.io.Serializable
 static {
        SINGLETON = new TwitterStreamImpl(ConfigurationContext.getInstance(), TwitterFactory.DEFAULT_AUTHORIZATION);
    }

工厂模式：
hadoop和spark里面关于日志模块都用了工厂模式去设计的
public abstract class LogFactory{}
 public static Log getLog(Class clazz) throws LogConfigurationException
        return getFactory().getInstance(clazz);

public final class TwitterStreamFactory implements java.io.Serializable
 static {
        SINGLETON = new TwitterStreamImpl(ConfigurationContext.getInstance(), TwitterFactory.DEFAULT_AUTHORIZATION);
    }

3. 宙斯之前有缓存系统，但是后面去除了，因为无法保持一致性问题，或者代价太大。因为job很多，不停的
写文件，需要不停的更新缓存，几乎每一分钟更新一次，这样太麻烦了，所以最后取消缓存了。直接去DBA里面
去读数据。
4. 如果是设计推荐系统的话，底层是Hbase的话，上层去查询的话，买了一个鼠标，接下来给他推荐一些东西，
这些东西就可以缓存起来，在Hbase上层加一个Redis缓存体系。
5. Master和Worker，作业的调度是最主要的，通信机制采用Netty实现RPC机制，RPC的底层实现采用
Socket和SocketServer进行通信。
6. 锁机制，如果Master结点半天没有反应,比如超过一段时间都没有反应，那么就进行unlock，如果采用
synchronized机制的话，你无法释放锁，所以采用lock机制，而不是采用synchronized机制来进行加锁
机制。当多个worker去争抢一个Master的时候，当其中一个Worker抢到了，要进行上锁，并向别的结点进
行宣布，我是Master了。

谈谈你对RPC的理解？
1. RPC首先要解决的就是TCP的连接问题，其次解决寻址问题，此外还有序列化框架的问题

NIO和传统IO（一下简称IO）之间第一个最大的区别是

＠１：IO是面向流的，NIO是面向缓冲区的
＠２：IO是同步操作，NIO是异步操作

NIO中的Channel的主要实现有：

FileChannel
DatagramChannel
SocketChannel
ServerSocketChannel
此外，基于transferTo还可以实现Zero-Copy问题























